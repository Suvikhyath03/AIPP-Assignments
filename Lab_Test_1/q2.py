# -*- coding: utf-8 -*-
"""Q2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19WLZ0gVkwkEwfg0dNtfrU-3w7M15M0Pc

Zero Shot
"""

# Define user_input safely (you can change this to actual input)
try:
    user_input
except NameError:
    user_input = ""   # default empty string if not defined


# Use an existing 'students' variable if present; otherwise try to parse user_input; fallback to sample data.
# Accepted formats:
# - students as dict: {'Alice': 85, 'Bob': 70}
# - students as list of (name, mark) tuples: [('Alice', 85), ...]
# - user_input as "Alice:85,Bob:70,Charlie:90"

if 'students' in globals() and students:
    src = students
elif user_input:
    src = {}
    for part in user_input.split(','):
        part = part.strip()
        if not part:
            continue
        if ':' in part:
            name, mark = part.split(':', 1)
            try:
                src[name.strip()] = float(mark)
            except ValueError:
                pass
        else:
            # if only marks provided, generate generic names
            try:
                mark = float(part)
                src[f"Student{len(src)+1}"] = mark
            except ValueError:
                pass
else:
    # fallback sample data
    src = {'Alice': 85, 'Bob': 70, 'Charlie': 90, 'Diana': 78, 'Evan': 92}


# Normalize src to dict of name->mark
if isinstance(src, dict):
    students_dict = {str(k): float(v) for k, v in src.items()}
else:
    students_dict = {str(k): float(v) for k, v in src}

marks = list(students_dict.values())

if not marks:
    print("No student marks available.")
else:
    mean_mark = sum(marks) / len(marks)
    above_mean = {name: mark for name, mark in students_dict.items() if mark > mean_mark}

    print(f"Mean mark: {mean_mark:.2f}")

    if above_mean:
        print("Students scoring above the mean:")
        for name, mark in sorted(above_mean.items(), key=lambda x: -x[1]):
            print(f"  {name}: {mark}")
    else:
        print("No student scored above the mean.")

"""One Shot"""

# Build or reuse a mapping of student -> mark, preferring an existing students_dict
if 'students_dict' in globals() and students_dict:
    sd = students_dict
elif 'students' in globals() and students:
    sd = {str(k): float(v) for k, v in (students.items() if isinstance(students, dict) else students)}
elif user_input:
    sd = {}
    for part in user_input.split(','):
        part = part.strip()
        if not part:
            continue
        if ':' in part:
            name, mark = part.split(':', 1)
            try:
                sd[name.strip()] = float(mark)
            except ValueError:
                pass
        else:
            try:
                mark = float(part)
                sd[f"Student{len(sd)+1}"] = mark
            except ValueError:
                pass
else:
    # fallback sample
    sd = {'A': 80, 'B': 60, 'C': 90}

if not sd:
    print("No student marks available.")
else:
    marks = list(sd.values())
    mean = sum(marks) / len(marks)
    above_mean = [name for name, mark in sd.items() if mark > mean]

    print(f"Mean = {mean:.2f}")
    print("Students above mean =", above_mean)

"""Few Shot"""

def mean_and_above(students=None):
    """
    Compute mean and list students scoring above the mean.
    Accepts:
      - dict mapping name->mark
      - iterable of (name, mark) pairs
      - iterable of marks (will generate Student1, Student2, ...)
    If students is None, tries to reuse students_dict, sd, or students from globals(),
    or parses user_input (format "A:50,B:60"), otherwise falls back to a sample.
    Returns: (mean, above_list)
    """
    # choose source if not provided
    if students is None:
        if 'students_dict' in globals() and students_dict:
            students = students_dict
        elif 'sd' in globals() and sd:
            students = sd
        elif 'students' in globals() and students:
            students = students
        elif user_input:
            tmp = {}
            for part in user_input.split(','):
                part = part.strip()
                if not part:
                    continue
                if ':' in part:
                    name, mark = part.split(':', 1)
                    try:
                        tmp[name.strip()] = float(mark)
                    except Exception:
                        pass
                else:
                    try:
                        mark = float(part)
                        tmp[f"Student{len(tmp)+1}"] = mark
                    except Exception:
                        pass
            students = tmp
        else:
            students = {'A': 50, 'B': 70, 'C': 90}  # fallback sample

    # normalize to dict of name -> float(mark)
    if isinstance(students, dict):
        sd_local = {str(k): float(v) for k, v in students.items()}
    else:
        try:
            sd_local = {str(k): float(v) for k, v in students}
        except Exception:
            sd_local = {f"Student{i+1}": float(v) for i, v in enumerate(students)}

    if not sd_local:
        print("No student marks available.")
        return None, []

    marks = list(sd_local.values())
    mean = sum(marks) / len(marks)
    above = [name for name, mark in sd_local.items() if mark > mean]

    # print similar format to examples
    mean_str = str(int(mean)) if mean.is_integer() else str(mean)
    print(f"Mean = {mean_str}")
    print(f"Above mean = {above}")

    return mean, above


# Demonstration with the examples from the prompt
mean_and_above({'A': 50, 'B': 70, 'C': 90})
mean_and_above({'Sam': 88, 'Joe': 92, 'Mia': 75, 'Ana': 95})

